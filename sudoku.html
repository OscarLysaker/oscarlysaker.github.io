<!--
    Source for fonts:
    https://fonts.google.com/?preview.text=0123456789%20Sudoku&preview.text_type=custom

    Imported fonts:
    Open Sans: https://fonts.google.com/specimen/Open+Sans?preview.text=0123456789%20Sudoku&preview.text_type=custom&sidebar.open=true&selection.family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300;1,400;1,600;1,700;1,800

-->

<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Sudoku</title>

    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300;1,400;1,600;1,700;1,800&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="css/sudoku-fixed.css">
</head>
<body>
    <div id="sudoku-root"></div>

    <script>

//      +--------------------------+
//      |      Preset Puzzles      |
//      +--------------------------+

        var samplePuzzles = {
            "easy" : [
                [0,6,0,0,8,0,4,2,0,
                 0,1,5,0,6,0,3,7,8,
                 0,0,0,4,0,0,0,6,0,
                 1,0,0,6,0,4,8,3,0,
                 3,0,6,0,1,0,7,0,5,
                 0,8,0,3,5,0,0,0,0,
                 8,3,0,9,4,0,0,0,0,
                 0,7,2,1,3,0,9,0,0,
                 0,0,9,0,2,0,6,1,0]
            ]
        }

//      +---------------------------+
//      |      Basic Variables      |
//      +---------------------------+

        // Element Access
        let root = null;
        let container = null;
        let table = null;

        // Cell arrays
        var cells = [];
        var cellsConflicting = [];

        // Selectors
        let selectedCell;
        let multiSelect = [];

        // Togglers
        let pencilActive = false;

        // Arrows movement
        let arrowActive = false;
        let arrowCell = null;

        // Drag
        let dragging = false;
        let dragFirstCell = null;

        // Cells
        let mouseOverCell = null;
        let mouseOverRoot = false;

        let mouseIsDown = false;

//      +--------------------------+
//      |      Enum Abstracts      |
//      +--------------------------+

        var CELL_ATTR = {
            TYPE : 'data-sudoku-cell-type',
            SELECTED : 'data-sudoku-cell-selected',
            ERROR : 'data-sudoku-cell-error',

            VALUE : 'data-value',
            POS_X : 'data-pos-x',
            POS_Y : 'data-pos-y',
            GROUP_INDEX : 'data-group-index',

            HIGHLIGHT : 'data-sudoku-cell-highlight',
            DIGIT_HIGHLIGHT : 'data-sudoku-digit-highlight',
            ARROW_HIGHLIGHT : 'data-sudoku-cell-arrow-highlight',
            PENCIL_HIGHLIGHT : 'data-sudoku-cell-pencil-highlight',
            PENCIL_HIGHLIGHT_DIGIT : 'data-sudoku-cell-pencil-highlight-digit'
        };

        let CELL_SELECTED = {
            SINGLE : 'single',
            MULTI : 'multi'
        };

        let CELL_HIGHLIGHT = {
            NONE : 'none'
        };

        let CELL_ERROR = {
            CELL : 'cell',
            DIGIT : 'digit'
        };

        let CELL_TYPE = {
            EMPTY : 'empty',
            NORMAL : 'normal',
            PENCIL : 'pencil',
            CLUE : 'clue'
        };

        let KEY_DOWN = {
            SHIFT : false,
            TAB : false,
            CTRL : false
        };

        let BUTTON_ATTR = {
            STATE : 'data-sudoku-button-state',

            TYPE_UNDO : 'data-sudoku-button-type-undo',
            TYPE_REDO : 'data-sudoku-button-type-redo',
            TYPE_DELETE : 'data-sudoku-button-type-delete',
            TYPE_PENCIL : 'data-sudoku-button-type-pencil',
            TYPE_HINT : 'data-sudoku-button-type-hint'
        };

        let BUTTON_STATE = {
            DISABLED : 'disabled',
            ACTIVE : 'active'
        };

//      +----------------------------+
//      |      Button Variables      |
//      +----------------------------+

        let buttonSample = createButton("New Sample", "sudoku-button-temp-sample-set", null, () => {
            console.log("Pressed sample button...");
            initPuzzle(samplePuzzles.easy[0]);
        });

        let buttonReset = createButton("Reset", "sudoku-button-reset", null, () => {
            console.log("Pressed reset button...");
            reset();
        });

        let buttonFillRandom = createButton("Fill Random", "sudoku-button-fill-random", null, () => {
            console.log("Pressed fill random button...");
            fillRandom();
        });

        let buttonSolve = createButton("Solve", "sudoku-button-redo", null, () => {
            solve();
        });

        let buttonTest = createButton("Test Button", "sudoku-test-button", "sudoku-button", () => {
            console.log("Pressed new button...");
        });

//      +---------------------------------+
//      |      Sudoku Initialization      |
//      +---------------------------------+

        function detectMob() {
            const toMatch = [
                /Android/i,
                /webOS/i,
                /iPhone/i,
                /iPad/i,
                /iPod/i,
                /BlackBerry/i,
                /Windows Phone/i
            ];

            return toMatch.some((toMatchItem) => {
                return navigator.userAgent.match(toMatchItem);
            });
        }

        function initSudokuInside (element=null) {
            if (element == null) return;

            root = element;

            // Style
            if (detectMob()) document.head.querySelector('[href="css/sudoku-fixed.css"]').setAttribute("href", "./css/sudoku-mobile.css");
            //document.head.querySelector('[href="css/sudoku-fixed.css"]').setAttribute("href", "./css/sudoku-mobile.css");

            // Container
            container = document.createElement("div");
            container.setAttribute("id", "sudoku-root-container");
            root.append(container);

            // Create logo
            let logo = document.createElement("h3");
            logo.setAttribute("class", "unselectable");
            logo.innerText = "Sudoku";
            container.append(logo);

            // Button container grid
            let buttonContainerGrid = document.createElement("div");
            buttonContainerGrid.setAttribute("id", "sudoku-root-container-buttons-grid");

            // Add buttons
            buttonContainerGrid.append(buttonSample);
            buttonContainerGrid.append(buttonReset);
            buttonContainerGrid.append(buttonFillRandom);
            buttonContainerGrid.append(buttonSolve);
            buttonContainerGrid.append(buttonTest);

            container.append(buttonContainerGrid);

            // Create Sudoku Table
            table = document.createElement("table");
            table.setAttribute("class", "unselectable");
            table.setAttribute("id", "sudoku-root-table");

            for(let y = 0; y < 9; y++) {
                var tableRow = document.createElement("tr");
                tableRow.setAttribute("id", "sudoku-root-row");
                for(let x = 0; x < 9; x++) {
                    var tableHeader = document.createElement("th");
                    tableHeader.setAttribute("id", "sudoku-root-cell");
                    tableHeader.setAttribute(CELL_ATTR.POS_X, x);
                    tableHeader.setAttribute(CELL_ATTR.POS_Y, y);
                    tableHeader.setAttribute(CELL_ATTR.GROUP_INDEX, Math.floor(y/3)*3 + Math.floor(x/3));
                    tableHeader.setAttribute(CELL_ATTR.TYPE, CELL_TYPE.EMPTY);

                    (function(cell, onCellPushed){
                        cell.addEventListener("mousedown", () => {
                            onCellPushed(cell);
                        });

                        cell.addEventListener("touchstart", () => {
                            onCellPushed(cell);
                        });
                    })(tableHeader, onCellPushed);

                    (function(cell, onCellOver){
                        cell.addEventListener("mouseover", (ev) => {
                            if (ev.buttons == 1 || ev.button == 1) {
                                onCellOver(cell);
                            }
                        });

                        cell.addEventListener("touchmove", (ev) => {
                            if (dragFirstCell != null || (multiSelect.length > 0 && multiSelect.indexOf(cell) < 0)) {
                                onCellOver(cell);
                            }
                        });
                    })(tableHeader, onCellOver);

                    (function(cell, onCellOut){
                        cell.addEventListener("mouseout", () => {
                            onCellOut(cell);
                        });
                    })(tableHeader, onCellOut);

                    setCellValue(tableHeader, 0, false, false);
                    cells.push(tableHeader);
                    tableRow.append(tableHeader);
                }
                table.append(tableRow);
            }
            container.append(table);

            // Button container settings
            let buttonContainerInput = document.createElement("div");
            buttonContainerInput.setAttribute("id", "sudoku-root-container-buttons-input");

            let buttonInputUndo = createButtonInput("Undo", "./svg/undo.svg", BUTTON_ATTR.TYPE_UNDO, (button, e) => {
                logUndoAction();
            });

            let buttonInputRedo = createButtonInput("Redo", "./svg/redo.svg", BUTTON_ATTR.TYPE_REDO, (button, e) => {
                logRedoAction();
            });

            let buttonInputDelete = createButtonInput("Delete", "./svg/eraser.svg", BUTTON_ATTR.TYPE_DELETE, (button, e) => {
                deleteDigit(true, true);
            });

            let buttonInputPencil = createButtonInput("Pencil", "./svg/pen-off.svg", BUTTON_ATTR.TYPE_PENCIL, (button, e) => {
                pencilModeToggle();
            });

            let buttonInputHint = createButtonInput("Hint", "./svg/hint.svg", BUTTON_ATTR.TYPE_HINT, (button, e) => {
                
            });

            buttonContainerInput.append(buttonInputUndo);
            buttonContainerInput.append(buttonInputRedo);
            buttonContainerInput.append(buttonInputDelete);
            buttonContainerInput.append(buttonInputPencil);
            buttonContainerInput.append(buttonInputHint);

            container.append(buttonContainerInput);

            // Button container input
            let buttonContainerInputNumbers = document.createElement("div");
            buttonContainerInputNumbers.setAttribute("id", "sudoku-root-container-buttons-input-numbers");

            // Buttons
            for (let i = 0; i < 9; i++) {
                let buttonNum = document.createElement("button");
                buttonNum.setAttribute("class", "sudoku-button-number-input");
                buttonNum.innerText = String(i+1);
                buttonNum.addEventListener("click", (button, e) => {
                    let newType = CELL_TYPE.NORMAL;
                    if (pencilActive) newType = CELL_TYPE.PENCIL;
                    setCellValue(null, i+1, true, true, newType);
                });
                buttonContainerInputNumbers.append(buttonNum);
            }

            container.append(buttonContainerInputNumbers);

            document.addEventListener("mouseup", () => {
                onMouseReleased();
            });

            container.addEventListener("mouseout", () => {
                mouseOverRoot = false;
            });

            container.addEventListener("mouseover", () => {
                mouseOverRoot = true;
            });

            document.addEventListener("mousedown", () => {
                onMousePressed();
            });

            document.addEventListener("touchend", () => {
                onMouseReleased();
            });

            document.addEventListener("touchcancel", () => {
                onMouseReleased();
            });
        }

//      +---------------------------+
//      |      Button Handlers      |
//      +---------------------------+

        function createButton (label="New Button", id="", cl="", clickCallback=null) {
            let newButton = document.createElement("button");
            if (id != "") newButton.setAttribute("id", id);
            if (cl != "") newButton.setAttribute("class", cl);
            newButton.innerText = label;
            if (clickCallback != null) newButton.addEventListener("click", clickCallback);
            return newButton;
        }

        function createButtonInput (label, imgSource, type, onClick) {
            let inputButton = document.createElement("button");
            inputButton.setAttribute("class", "sudoku-button-input");
            inputButton.setAttribute(type, "");

            let inputButtonIcon = document.createElement("img");
            inputButtonIcon.setAttribute("src", imgSource);
            inputButton.append(inputButtonIcon);

            let inputButtonLabel = document.createElement("div");
            inputButtonLabel.setAttribute("id", "sudoku-button-input-label");
            inputButtonLabel.innerText = label;
            inputButton.append(inputButtonLabel);

            inputButton.addEventListener("click", (button, e) => {
                onClick(button, e);
            });

            return inputButton;
        }

//      +--------------------------------+
//      |      Interaction Handlers      |
//      +--------------------------------+

        function onCellPushed (cell) {
            arrowRemove();
            selectSingleCell(cell);
            dragFirstCell = cell;
        }

        function onMousePressed () {
            if (!mouseOverRoot) selectionRemoveAll();
        }

        function onMouseReleased () {
            dragging = false;
            dragFirstCell = null;
        }

        function onCellOver (cell) {
            console.log("OVER CELL");
            mouseOverCell = cell;
            if (!dragging && dragFirstCell != cell && dragFirstCell != null) {
                dragging = true;
                selectMultiBegin();
                selectMultiAdd(dragFirstCell);
                dragFirstCell = null;
                selectMultiAdd(cell);
            } else if (dragging) {
                selectMultiAdd(cell);
            }
        }

        function onCellOut (cell) {
            if (mouseOverCell == cell) mouseOverCell = null;
        }

//      +------------------------------+
//      |      Selection Handlers      |
//      +------------------------------+

        function selectionRemoveAll () {
            selectedCell = null;
            multiSelect = [];
            removeHighlights();
            document.querySelectorAll('[' + CELL_ATTR.SELECTED + ']').forEach((value, key, parent) => {
                value.removeAttribute(CELL_ATTR.SELECTED);
            });
        }

        function selectSingleCell (cell) {
            selectionRemoveAll();
            selectedCell = cell;
            selectedCell.setAttribute(CELL_ATTR.SELECTED, CELL_SELECTED.SINGLE);
            highlightCellsFor(selectedCell);
            pencilUpdateHighlights();
        }

        function selectMultiAdd (cell) {
            if (multiSelect.length == 0 || multiSelect.indexOf(cell) < 0) {
                cell.setAttribute(CELL_ATTR.SELECTED, CELL_SELECTED.MULTI);
                multiSelect.push(cell);
            }
        }

        function selectMultiBegin () {
            let tempCell = selectedCell;
            selectionRemoveSingle();
            removeHighlights();
            if (tempCell != null) selectMultiAdd(tempCell);
        }

        function selectionRemoveSingle () {
            if (selectedCell != null) {
                selectedCell.removeAttribute(CELL_ATTR.SELECTED);
                removeHighlights();
                selectedCell = null;
            }
        }

        function selectionRemoveMulti () {
            if (multiSelect.length > 0) {
                document.querySelectorAll('[' + CELL_ATTR.SELECTED + '="' + CELL_SELECTED.MULTI + '"]').forEach((value, key, parent) => {
                    value.removeAttribute(CELL_ATTR.SELECTED);
                });
                multiSelect = [];
            }
        }

//      +--------------------------+
//      |      Arrow Handlers      |
//      +--------------------------+

        function arrowMove (cellsX=0, cellsY=0) {
            let newX = 0;
            let newY = 0;
            if (selectedCell == null && multiSelect.length == 0 && arrowCell == null) {
                if (cellsX > 0) {
                    newX = 0;
                    newY = 4;
                } else if (cellsX < 0) {
                    newX = 8;
                    newY = 4;
                } else if (cellsY > 0) {
                    newX = 4;
                    newY = 0;
                } else if (cellsY < 0) {
                    newX = 4;
                    newY = 8;
                } else {
                    return;
                }
            } else {
                if (arrowCell == null) {
                    if (selectedCell != null) {
                        arrowCell = selectedCell;
                    } else if (multiSelect.length > 0) {
                        arrowCell = multiSelect[0];
                    } else {
                        return;
                    }
                }
                newX = parseInt(arrowCell.getAttribute(CELL_ATTR.POS_X));
                newY = parseInt(arrowCell.getAttribute(CELL_ATTR.POS_Y));
                if (cellsX > 0) newX++;
                else if (cellsX < 0) newX--;
                else if (cellsY > 0) newY++;
                else if (cellsY < 0) newY--;
            }

            if (newX > 8) newX = 0;
            if (newX < 0) newX = 8;
            if (newY > 8) newY = 0;
            if (newY < 0) newY = 8;
            
            arrowSet(getCellAt(newX, newY));
            if (selectedCell != null && multiSelect.length == 0 && KEY_DOWN.SHIFT) {
                selectMultiBegin();
                selectMultiAdd(arrowCell);
            } else if (multiSelect.length > 0 && KEY_DOWN.SHIFT) {
                selectMultiAdd(arrowCell);
            } else {
                selectSingleCell(arrowCell);
            }
        }

        function arrowSet (cell) {
            if (arrowCell != null) arrowRemove();

            arrowCell = cell;
            arrowCell.setAttribute(CELL_ATTR.ARROW_HIGHLIGHT, "");
        }

        function arrowRemove () {
            if (arrowCell == null) return;

            arrowCell.removeAttribute(CELL_ATTR.ARROW_HIGHLIGHT);
            arrowCell = null;
        }

//      +---------------------------+
//      |      Pencil Handlers      |
//      +---------------------------+

        function pencilModeToggle () {
            if (pencilActive) pencilModeEnd();
            else pencilModeStart();
        }

        function pencilModeStart () {
            if (pencilActive) return;
            pencilActive = true;
            document.querySelector('[' + BUTTON_ATTR.TYPE_PENCIL + ']').setAttribute(BUTTON_ATTR.STATE, BUTTON_STATE.ACTIVE);
            document.querySelector('[src="./svg/pen-off.svg"]').setAttribute("src", "./svg/pen-on.svg");
        }

        function pencilModeEnd () {
            if (!pencilActive) return;
            pencilActive = false;
            document.querySelector('[' + BUTTON_ATTR.TYPE_PENCIL + ']').removeAttribute(BUTTON_ATTR.STATE);
            document.querySelector('[src="./svg/pen-on.svg"]').setAttribute("src", "./svg/pen-off.svg");
        }

        function checkPencilMarksOnInput (inputCell) {
            
        }

        function pencilUpdateHighlights () {
            // Remove highlight
            document.querySelectorAll('[' + CELL_ATTR.TYPE + '=' + CELL_TYPE.PENCIL + ']').forEach((value, key, parent) => {
                value.innerHTML = String(value.getAttribute(CELL_ATTR.VALUE));
            });

            // Update highlights
            if (selectedCell != null && (selectedCell.getAttribute(CELL_ATTR.TYPE) != CELL_TYPE.NORMAL && selectedCell.getAttribute(CELL_ATTR.TYPE) != CELL_TYPE.CLUE)) return;
            document.querySelectorAll('[' + CELL_ATTR.TYPE + ']').forEach((value, ket, parent) => {
                console.log("Checking pencil cell...");
                if (value.getAttribute(CELL_ATTR.TYPE) == CELL_TYPE.PENCIL) {
                    let cellValue = "" + String(value.getAttribute(CELL_ATTR.VALUE));
                    let selectedValue = "" + String(selectedCell.getAttribute(CELL_ATTR.VALUE));
                    if (cellValue.indexOf(selectedValue) >= 0) {
                        console.log("Cell has selected value!!");
                        console.log("Found value " + selectedValue + " inside " + cellValue);

                        value.innerHTML = "";

                        let tempSpanLow = document.createElement("span");
                        tempSpanLow.setAttribute(CELL_ATTR.PENCIL_HIGHLIGHT, "");

                        let tempSpanHigh = document.createElement("span");
                        tempSpanHigh.setAttribute(CELL_ATTR.PENCIL_HIGHLIGHT_DIGIT, "");
                        tempSpanHigh.innerText = selectedValue;

                        let splitValue = cellValue.split("");
                        for (let x = 0; x < splitValue.length; x++) {
                            if (splitValue[x] == selectedValue) {
                                if (tempSpanLow.innerText != "") value.append(tempSpanLow);
                                tempSpanLow = document.createElement("span");
                                tempSpanLow.setAttribute(CELL_ATTR.PENCIL_HIGHLIGHT, "");
                                value.append(tempSpanHigh);
                            } else {
                                tempSpanLow.append(splitValue[x]);
                            }
                        }

                        if (tempSpanLow.innerText != "") value.append(tempSpanLow);

                        //cellValue = cellValue.replace(selectedValue, String('<div id="' + CELL_ATTR.PENCIL_HIGHLIGHT + '">' + selectedValue + '</div>'));
                        console.log("Modified cell value = " + cellValue);
                        //value.innerHTML = cellValue;
                        console.log("New pencil value = " + value.innerText);
                    }
                }
            });
        }

//      +-------------------------+
//      |      Grid Handlers      |
//      +-------------------------+

        function reset () {
            console.log("Resetting sudoku puzzle...");
            selectionRemoveAll();
            pencilModeEnd();
            document.querySelector('[' + BUTTON_ATTR.TYPE_HINT + ']').setAttribute(BUTTON_ATTR.STATE, BUTTON_STATE.DISABLED);
            for (let x = 0; x < cells.length; x++) {
                let cell = cells[x];
                setCellValue(cell, 0, false, false, CELL_TYPE.EMPTY);
                removeAllAttributes(cell);
            }
            logReset();
            console.log("Sudoku successfully reset!");
        }

        function fillRandom () {
            reset();
            for (let i = 0; i < cells.length; i++) {
                setCellValue(cells[i], Math.round(Math.random() * 9), false, false);
            }
        }

//      +------------------------------+
//      |      Attribute Handlers      |
//      +------------------------------+

        function removeAllAttributes (cell) {
            cell.removeAttribute(CELL_ATTR.HIGHLIGHT);
            cell.removeAttribute(CELL_ATTR.DIGIT_HIGHLIGHT);
            cell.setAttribute(CELL_ATTR.TYPE, CELL_TYPE.EMPTY);
            cell.removeAttribute(CELL_ATTR.ERROR);
        }

        function removeAllAttributesFromAllCells () {
            for (i = 0; i < cells.length; i++) removeAllAttributes(cells[i]);
        }

//      +-----------------------------+
//      |      Cell Manipulation      |
//      +-----------------------------+

        function setCellValue (cells, value, playerInput=false, log=false, forcedType=CELL_TYPE.EMPTY) {
            
            if (cells == null) {
                if (selectedCell != null) cells = [selectedCell];
                else if (multiSelect.length > 0) {
                    cells = [];
                    for (let i in multiSelect) {
                        cells.push(multiSelect[i]);
                    }
                } else return;
            }
            
            if (!Array.isArray(cells)) cells = [cells];

            let affectedCells = [];
            let previousValues = [];
            let previousTypes = [];

            let newValues = [];
            let newTypes = [];

            // New values
            let newType = forcedType;
            if (pencilActive && playerInput) newType = CELL_TYPE.PENCIL;
            else if (value != 0 && !playerInput && forcedType != CELL_TYPE.PENCIL && forcedType != CELL_TYPE.CLUE) newType = CELL_TYPE.NORMAL;
            else if (value != 0 && playerInput && !pencilActive) newType = CELL_TYPE.NORMAL;
            let newValue = value;
            let newInnerText = value.toString();
            if (newValue == 0) newInnerText = "";

            for (let i = 0; i < cells.length; i++) {
                let cell = cells[i];

                // Clue cells can't be manipulated by player, skip
                if (cell.getAttribute(CELL_ATTR.TYPE) == CELL_TYPE.CLUE && playerInput) continue;

                // Temp values prone for manipulation
                let tempNewType = newType;
                let tempNewValue = newValue;
                let tempNewInnerText = newInnerText;

                // Current values
                let currentType = cell.getAttribute(CELL_ATTR.TYPE);
                let currentValue = cell.getAttribute(CELL_ATTR.VALUE);

                // If value is 0 or previous value, delete value
                if (tempNewValue == 0 || (tempNewValue == currentValue && currentType == tempNewType)) {
                    tempNewType = CELL_TYPE.EMPTY;
                    tempNewInnerText = "";
                    tempNewValue = 0;
                } else {
                    // Check pencil
                    if (tempNewType == CELL_TYPE.PENCIL && String(tempNewValue).length > 1) {
                        console.log("Changing to multivalue of PENCIL cell: " + currentValue + " -> " + tempNewValue);
                    } else if (tempNewType == CELL_TYPE.PENCIL && currentType == CELL_TYPE.PENCIL) {
                        let valueArray = String(currentValue).split("");
                        let canPlaceValue = true;
                        tempNewInnerText = "";
                        for (let x = 0; x < valueArray.length; x++) {
                            let checkValue = valueArray[x];
                            if (checkValue == tempNewValue) {
                                canPlaceValue = false;
                                continue;
                            }
                            if (checkValue > tempNewValue && canPlaceValue) {
                                tempNewInnerText += String(tempNewValue);
                                canPlaceValue = false;
                            }
                            tempNewInnerText += checkValue;
                            if (x == valueArray.length - 1 && canPlaceValue) {
                                tempNewInnerText += String(tempNewValue);
                            }
                        }
                        tempNewValue = parseInt(tempNewInnerText);
                    }
                }

                // Store values
                affectedCells.push(cell);
                previousValues.push(currentValue);
                previousTypes.push(currentType);
                newValues.push(tempNewValue);
                newTypes.push(tempNewType);

                // Apply values
                cell.innerText = tempNewInnerText;
                cell.setAttribute(CELL_ATTR.VALUE, tempNewValue);
                console.log("Setting cell to [" + tempNewType + "] inside manipulation func...");
                cell.setAttribute(CELL_ATTR.TYPE, tempNewType);

                // If applied number, check if pencils should be removed
                if (tempNewType == CELL_TYPE.NORMAL && playerInput) {
                    let checkCells = [];
                    
                    let cellsRow = getCellRow(parseInt(cell.getAttribute(CELL_ATTR.POS_Y)));
                    let cellsColumn = getCellColumn(parseInt(cell.getAttribute(CELL_ATTR.POS_X)));
                    let cellsGroup = getCellGroup(parseInt(cell.getAttribute(CELL_ATTR.GROUP_INDEX)));

                    console.log("Captured " + (cellsRow.length + cellsColumn.length + cellsGroup.length) + " cells...");

                    for (let x = 0; x < cellsRow.length; x++) {
                        if (checkCells.indexOf(cellsRow[x]) < 0 && cellsRow[x] != cell && cellsRow[x].getAttribute(CELL_ATTR.TYPE) == CELL_TYPE.PENCIL) checkCells.push(cellsRow[x]);
                        if (checkCells.indexOf(cellsColumn[x]) < 0 && cellsColumn[x] != cell && cellsColumn[x].getAttribute(CELL_ATTR.TYPE) == CELL_TYPE.PENCIL) checkCells.push(cellsColumn[x]);
                        if (checkCells.indexOf(cellsGroup[x]) < 0 && cellsGroup[x] != cell && cellsGroup[x].getAttribute(CELL_ATTR.TYPE) == CELL_TYPE.PENCIL) checkCells.push(cellsGroup[x]);
                    }

                    console.log("Checking " + checkCells.length + " cells...");

                    for (let x = 0; x < checkCells.length; x++) {
                        if (String(checkCells[x].getAttribute(CELL_ATTR.VALUE)).indexOf(String(tempNewValue)) < 0) continue;
                        let checkCellValue = checkCells[x].getAttribute(CELL_ATTR.VALUE);
                        
                        affectedCells.push(checkCells[x]);
                        previousValues.push(checkCellValue);
                        previousTypes.push(checkCells[x].getAttribute(CELL_ATTR.TYPE));

                        let checkCellNewInnerText = String(checkCellValue).replace(String(tempNewValue), "");

                        if (checkCellNewInnerText == "") {
                            newValues.push(0);
                            newTypes.push(CELL_TYPE.EMPTY);

                            checkCells[x].setAttribute(CELL_ATTR.VALUE, 0);
                            checkCells[x].setAttribute(CELL_ATTR.TYPE, CELL_TYPE.EMPTY);
                        } else {
                            newValues.push(parseInt(checkCellNewInnerText));
                            newTypes.push(CELL_TYPE.PENCIL);

                            checkCells[x].setAttribute(CELL_ATTR.VALUE, parseInt(checkCellNewInnerText));
                            checkCells[x].setAttribute(CELL_ATTR.TYPE, CELL_TYPE.PENCIL);
                        }

                        checkCells[x].innerText = checkCellNewInnerText;
                    }
                }
            }

            if (selectedCell != null) {
                highlightCellsFor(selectedCell);
                if (selectedCell.getAttribute(CELL_ATTR.TYPE) == CELL_TYPE.NORMAL) pencilUpdateHighlights();
            }

            updateErrorHighlights();

            if (log) logAction(HISTORY_TYPE.CELL_VALUE, affectedCells, previousValues, newValues, previousTypes, newTypes);
        }

        function deleteDigit (playerInput=false, log=false) {
            if (selectedCell == null && multiSelect.length == 0) return;
            let cellsAffected = [];
            if (selectedCell != null) cellsAffected = [selectedCell];
            else cellsAffected = multiSelect;
            setCellValue(cellsAffected, 0, playerInput, log, CELL_TYPE.EMPTY);
        }

//      +-----------------------+
//      |      Grid Access      |
//      +-----------------------+

        function getCellAt (x, y) {
            return cells[y * 9 + x];
        }

        function getCellGroup (gIndex) {
            let groupX = (gIndex%3)*3;
            let groupY = Math.floor(gIndex/3)*3;
            let result = [];

            for (let x = 0; x < 3; x++) for (y = 0; y < 3; y++) {
                result.push(cells[(groupY + y) * 9 + groupX + x]);
            }

            return result;
        }

        function getCellRow (yIndex) {
            let result = [];
            for (let x = 0; x < 9; x++) result.push(cells[yIndex * 9 + x]);
            return result;
        }

        function getCellColumn (xIndex) {
            let result = [];
            for (let y = 0; y < 9; y++) result.push(cells[y * 9 + xIndex]);
            return result;
        }

//      +------------------------------+
//      |      Highlight Handlers      |
//      +------------------------------+

        function removeHighlights () {
            for (let i = 0; i < cells.length; i++) {
                cells[i].removeAttribute(CELL_ATTR.HIGHLIGHT);
                cells[i].removeAttribute(CELL_ATTR.DIGIT_HIGHLIGHT);
            }
        }

        function highlightCellsFor (cell) {
            removeHighlights();

            let cellType = cell.getAttribute(CELL_ATTR.TYPE);
            if (cellType == CELL_TYPE.EMPTY || cellType == CELL_TYPE.PENCIL) return;
            
            var cellX = parseInt(cell.getAttribute(CELL_ATTR.POS_X));
            var cellY = parseInt(cell.getAttribute(CELL_ATTR.POS_Y));

            for (let x = 0; x < 9; x++) {
                if (x == cellX) continue;
                getCellAt(x, cellY).setAttribute(CELL_ATTR.HIGHLIGHT, "");
            }

            for (let y = 0; y < 9; y++) {
                if (y == cellY) continue;
                getCellAt(cellX, y).setAttribute(CELL_ATTR.HIGHLIGHT, "");
            }

            var groupX = Math.floor(cellX/3) * 3;
            var groupY = Math.floor(cellY/3) * 3;

            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    if (cellX == groupX + x && cellY == groupY + y) continue;
                    getCellAt(groupX + x, groupY + y).setAttribute(CELL_ATTR.HIGHLIGHT, "");
                }
            }

            // Highlight digits
            if (cell.getAttribute(CELL_ATTR.VALUE) != 0 && cell.getAttribute(CELL_ATTR.TYPE) != CELL_TYPE.PENCIL) {
                let value = cell.getAttribute(CELL_ATTR.VALUE);
                for (let i = 0; i < cells.length; i++) {
                    let tempCell = cells[i];
                    if (tempCell == cell) continue;
                    if (tempCell.getAttribute(CELL_ATTR.TYPE) == CELL_TYPE.PENCIL) continue;
                    if (tempCell.getAttribute(CELL_ATTR.VALUE) == value) {
                        tempCell.setAttribute(CELL_ATTR.DIGIT_HIGHLIGHT, "");
                    }
                }
            }
        }

//      +------------------+
//      |      Events      |
//      +------------------+

        addEvent(document, "keypress", function (e) {
            e = e || window.event;
            // use e.keyCode

            console.log(e.keyCode);

            if (e.keyCode >= 48 && e.keyCode <= 57) { // Nums [0-9]
                let after = e.keyCode - 48;
                if (multiSelect.length > 1) {
                    let cells = [];
                    for (let i = 0; i < multiSelect.length; i++) {
                        if (multiSelect[i].getAttribute(CELL_ATTR.TYPE) == CELL_TYPE.CLUE) continue;
                        cells.push(multiSelect[i]);
                    }
                    //setValue(cells, after, true, true);
                    setCellValue(cells, after, true, true);
                } else if (selectedCell != null && selectedCell.getAttribute(CELL_ATTR.TYPE) != CELL_TYPE.CLUE) {
                    //setValue(selectedCell, after, true, true);
                    setCellValue(selectedCell, after, true, true);
                    highlightCellsFor(selectedCell);
                }
            } else if (e.keyCode >= 37 && e.keyCode <= 40) {
                switch (e.keyCode) {
                    case 37:
                        arrowMove(-1, 0);
                        break;
                    case 38:
                        arrowMove(0, -1);
                        break;
                    case 39:
                        arrowMove(1, 0);
                        break;
                    case 40:
                        arrowMove(0, 1);
                        break;
                    default:
                }
            }
        });

        addEvent(document, "keydown", function (e) {
            e = e || window.event;
            // use e.keyCode

            switch (e.key) {
                case "Delete": // Delete
                case "Backspace": // Backspace
                    console.log("pressed delete...");
                    deleteDigit(true, true);
                    break;
                case "p":
                    pencilModeToggle();
                    break;
                case "r":
                    reset();
                    break;
                case "z":
                    if (KEY_DOWN.CTRL) logUndoAction();
                    break;
                case "y":
                    if (KEY_DOWN.CTRL) logRedoAction();
                    break;
                case "Tab": KEY_DOWN.TAB = true; break;
                case "Control": KEY_DOWN.CTRL = true; break;
                case "Shift": KEY_DOWN.SHIFT = true; break;
                default:
            }

            switch (e.keyCode) {
                case 37:
                    arrowMove(-1, 0);
                    break;
                case 38:
                    arrowMove(0, -1);
                    break;
                case 39:
                    arrowMove(1, 0);
                    break;
                case 40:
                    arrowMove(0, 1);
                    break;
                default:
                }
        });

        addEvent(document, "keyup", function (e) {
            e = e || window.event;
            // use e.keyCode

            switch (e.key) {
                case "Tab": KEY_DOWN.TAB = false; break;
                case "Control": KEY_DOWN.CTRL = false; break;
                case "Shift": KEY_DOWN.SHIFT = false; break;
                default:
            }
        });

        function addEvent(element, eventName, callback) {
            if (element.addEventListener) {
                element.addEventListener(eventName, callback, false);
            } else if (element.attachEvent) {
                element.attachEvent("on" + eventName, callback);
            } else {
                element["on" + eventName] = callback;
            }
        }

//      +---------------------------+
//      |      Puzzle Handlers      |
//      +---------------------------+

        function initPuzzle (puzzle) {
            reset();
            document.querySelector('[' + BUTTON_ATTR.TYPE_HINT + ']').removeAttribute(BUTTON_ATTR.STATE);
            for (let i = 0; i < cells.length; i++) {
                setCellValue(cells[i], puzzle[i], false, false, CELL_TYPE.CLUE);
            }
        }

//      +--------------------------+
//      |      Error Handlers      |
//      +--------------------------+

        function updateErrorHighlights () {
            console.log("UPDATING ERRROOORRRRRR");

            document.querySelectorAll('[' + CELL_ATTR.ERROR + ']').forEach((value, key, parent) => { 
                value.removeAttribute(CELL_ATTR.ERROR);
            });

            let groups = []; // rows = [], columns = [];
            let rows = [];
            let columns = [];

            // Check conflicting cells
            for (let i = 1; i < 10; i++) {
                let checkCells = document.querySelectorAll('[' + CELL_ATTR.VALUE + '="' + i + '"]');
                for (let i0 = 0; i0 < checkCells.length; i0++) {
                    if (checkCells[i0].getAttribute(CELL_ATTR.TYPE) == CELL_TYPE.PENCIL) continue;
                    for (let i1 = 0; i1 < checkCells.length; i1++) {
                        if (checkCells[i1].getAttribute(CELL_ATTR.TYPE) == CELL_TYPE.PENCIL) continue;
                        if (i0 == i1) continue;
                        let cell0 = checkCells.item(i0);
                        let cell1 = checkCells.item(i1);

                        if ((cell0.getAttribute(CELL_ATTR.POS_X) == cell1.getAttribute(CELL_ATTR.POS_X))) {
                            if (columns.indexOf(cell0.getAttribute(CELL_ATTR.POS_X)) < 0) columns.push(cell0.getAttribute(CELL_ATTR.POS_X));
                            cell0.setAttribute(CELL_ATTR.ERROR, CELL_ERROR.DIGIT);
                            cell1.setAttribute(CELL_ATTR.ERROR, CELL_ERROR.DIGIT);
                        }
                        if ((cell0.getAttribute(CELL_ATTR.POS_Y) == cell1.getAttribute(CELL_ATTR.POS_Y))) {
                            if (rows.indexOf(cell0.getAttribute(CELL_ATTR.POS_Y)) < 0) rows.push(cell0.getAttribute(CELL_ATTR.POS_Y));
                            cell0.setAttribute(CELL_ATTR.ERROR, CELL_ERROR.DIGIT);
                            cell1.setAttribute(CELL_ATTR.ERROR, CELL_ERROR.DIGIT);
                        }
                        if ((cell0.getAttribute(CELL_ATTR.GROUP_INDEX) == cell1.getAttribute(CELL_ATTR.GROUP_INDEX))) {
                            if (groups.indexOf(cell0.getAttribute(CELL_ATTR.GROUP_INDEX)) < 0) groups.push(cell0.getAttribute(CELL_ATTR.GROUP_INDEX));
                            cell0.setAttribute(CELL_ATTR.ERROR, CELL_ERROR.DIGIT);
                            cell1.setAttribute(CELL_ATTR.ERROR, CELL_ERROR.DIGIT);
                        }
                    }
                }
            }

            // Highlight groups
            for (let i in groups) {
                let groupIndex = parseInt(groups[i]);

                let groupX = (groupIndex%3)*3;
                let groupY = Math.floor(groupIndex/3)*3;

                for (let x = 0; x < 3; x++) {
                    for (let y = 0; y < 3; y++) {
                        let checkCell = getCellAt(groupX + x, groupY + y);
                        if (!checkCell.hasAttribute(CELL_ATTR.ERROR)) checkCell.setAttribute(CELL_ATTR.ERROR, CELL_ERROR.CELL);
                    }
                }
            }

            // Highlight rows
            for (let i in rows) {
                let rowIndex = parseInt(rows[i]);
                for (let x = 0; x < 9; x++) {
                    let checkCell = getCellAt(x, rowIndex);
                    if (!checkCell.hasAttribute(CELL_ATTR.ERROR)) checkCell.setAttribute(CELL_ATTR.ERROR, CELL_ERROR.CELL);
                }
            }

            // Highlight rows
            for (let i in columns) {
                let columnIndex = parseInt(columns[i]);
                for (let y = 0; y < 9; y++) {
                    let checkCell = getCellAt(columnIndex, y);
                    if (!checkCell.hasAttribute(CELL_ATTR.ERROR)) checkCell.setAttribute(CELL_ATTR.ERROR, CELL_ERROR.CELL);
                }
            }

            console.log("NUMBER OF CONFLICTING CELLS: " + cellsConflicting.length);
        }

        function checkIfFilled () {
            for (let x in cells) {
                let cell = cells[x];
                if (cell.getAttribute(CELL_ATTR.VALUE) == 0) {
                    return;
                }
            }

            if (cellsConflicting.length > 0) {
                return;
            }

            alert("You did it! Puzzle solved!");
        }

        
//      +-------------------+
//      |      History      |
//      +-------------------+


        var historyCurrentIndex = -1;
        let history = [];
        var HISTORY_TYPE = {
            CELL_VALUE : 'changed-multi-value'
        }

        function logReset () {
            history = [];
            historyCurrentIndex = -1;
        }

        function logIsEmpty () { return historyCurrentIndex == -1; }

        function logGetCurrent () {
            if (historyCurrentIndex == -1) return null;
            return history[historyCurrentIndex + 1];
        }

        function logAction (_logType, cells, valuesBefore, valuesAfter, typesBefore, typesAfter) {
            let historyStructure = {logType:_logType}
            let doLogNewStructure = false;
            switch (_logType) {
                case HISTORY_TYPE.CELL_VALUE:
                    let affectedCells = [];
                    let newValuesBefore = [];
                    let newValuesAfter = [];
                    let newTypesBefore = [];
                    let newTypesAfter = [];
                    //alert("Registering multiselect log with " + cell.length + " cells and " + before.length + " previous values...");
                    for (let i = 0; i < cells.length; i++) {
                        if (valuesBefore[i] == valuesAfter[i] && typesBefore[i] == typesAfter[i]) continue;
                        affectedCells.push(cells[i]);
                        newValuesBefore.push(valuesBefore[i]);
                        newTypesBefore.push(typesBefore[i]);
                        newValuesAfter.push(valuesAfter[i]);
                        newTypesAfter.push(typesAfter[i]);
                    }
                    //alert("After filter logged with " + affectedCells.length + " cells and " + newBefore.length + " previous values...");
                    historyStructure.cells = affectedCells;
                    historyStructure.valuesBefore = newValuesBefore;
                    historyStructure.typesBefore = newTypesBefore;
                    historyStructure.valuesAfter = newValuesAfter;
                    historyStructure.typesAfter = newTypesAfter;
                    doLogNewStructure = true;
                    break;
                default:
            }

            if (doLogNewStructure) {

                if (history.length != 0 && historyCurrentIndex < history.length - 1) {
                    history.splice(historyCurrentIndex + 1, history.length - historyCurrentIndex - 1);
                }

                history.push(historyStructure);
                historyCurrentIndex = history.length - 1;
            }
        }
        function logUndoAction () {
            if (historyCurrentIndex == -1) return;
            
            let action = history[historyCurrentIndex];

            switch (action.logType) {
                case HISTORY_TYPE.CELL_VALUE:
                    //alert("Attempting to undo multi-select of " + action.cells.length + " cells...");
                    for(let i = 0; i < action.cells.length; i++) {
                        //alert("Setting cell " + i + " to previous value " + action.before[i] + "...");
                        setCellValue(action.cells[i], action.valuesBefore[i], false, false, action.typesBefore[i]);
                    }
                    historyCurrentIndex--;
                    return;
                default:
            }
        }

        function logRedoAction () {
            if (historyCurrentIndex == history.length - 1) return;

            let action = history[historyCurrentIndex + 1];

            switch (action.logType) {
                case HISTORY_TYPE.CELL_VALUE:
                    historyCurrentIndex++;
                    for (let i = 0; i < action.cells.length; i++) {
                        console.log("Setting cell to type " + action.typesAfter[i]);
                        setCellValue(action.cells[i], action.valuesAfter[i], false, false, action.typesAfter[i]);
                    }
                    return;
                default:
            }
        }

//      +------------------+
//      |      Solver      |
//      +------------------+

        function solve () {
            // Construct solve grid structure
            let gridArray = []
            for (let i = 0; i < cells.length; i++) {
                let cellStructure = {};
                /*
                {
                    cell : cells[i],
                    value : cells[i].getAttribute(CELL_ATTR.VALUE),
                    possible : [],
                    x : parseInt(cells[i].getAttribute(CELL_ATTR.POS_X)),
                    y : parseInt(cells[i].getAttribute(CELL_ATTR.POS_Y)),
                    groupIndex : parseInt(cells[i].getAttribute(CELL_ATTR.GROUP_INDEX)),
                    type : cells[i].getAttribute(CELL_ATTR.TYPE)
                };
                */
                cellStructure.cell = cells[i];
                cellStructure.value = cells[i].getAttribute(CELL_ATTR.VALUE);
                console.log(cellStructure.value);
                cellStructure.possible = [];
                cellStructure.x = parseInt(cells[i].getAttribute(CELL_ATTR.POS_X));
                cellStructure.y = parseInt(cells[i].getAttribute(CELL_ATTR.POS_Y));
                cellStructure.groupIndex = parseInt(cells[i].getAttribute(CELL_ATTR.GROUP_INDEX));
                cellStructure.type = cells[i].getAttribute(CELL_ATTR.TYPE);
                gridArray.push(cellStructure);
            }

            console.log("solving grid: " + gridArray)

            // Fill possible numbers
            for (let i = 0; i < gridArray.length; i++) {
                let checkCell = gridArray[i];
                if (checkCell.type == CELL_TYPE.CLUE || checkCell.value != 0) continue;
                checkCell.possible = solveGetAllowedValues(gridArray, i);
                console.log("Possible values for cell [" + checkCell.x + "x" + checkCell.y + "] is " + checkCell.possible);
            }

            // Recursive solve
            let allCellsSolved = false;
            while (!allCellsSolved) {
                console.log("Grid not filled yet...");

                let gotStuck = true;
                for (let i = 0; i < gridArray.length; i++) {
                    if (!gotStuck) continue;

                    let checkCell = gridArray[i];

                    if (checkCell.value == 0 && checkCell.possible.length == 1) {
                        console.log("Setting cell [" + checkCell.x + "x" + checkCell.y + "] value to " + checkCell.possible[0] + "...");
                        checkCell.value = checkCell.possible[0];
                        checkCell.possible = [];
                        solveUpdateAllowedValues(gridArray, i);
                        console.log("Found cell with only possible length of 1...");
                        gotStuck = false;
                    }

                    if (gotStuck) {
                        for (let checkValueIndex = 0; checkValueIndex < checkCell.possible.length; checkValueIndex++) {
                            if (gotStuck) continue;
                            let checkValue = checkCell.possible[checkValueIndex];
                            if (solveOnlyPossible(gridArray, i, checkValue)) {
                                checkCell.value = checkValue;
                                checkCell.possible = [];
                                solveUpdateAllowedValues(gridArray, i);
                                gotStuck = false;
                                console.log("Found cell with only 1 possible value...");
                            }
                        }
                    }
                }
                if (gotStuck) {
                    alert("Got stuck in recursive loop for solver...");
                    break;
                }

                allCellsSolved = allCellsFilled(gridArray);
                console.log("Solved status = " + allCellsSolved);
            }

            // Fill solved grid
            console.log("Solving grid, changing " + gridArray.length + " values..");
            for (let i = 0; i < gridArray.length; i++) {
                if (gridArray[i].type == CELL_TYPE.CLUE) continue;
                console.log("Setting cell [" + gridArray[i].x + "x" + gridArray[i].y + "] to " + gridArray[i].value + "...");
                setCellValue(gridArray[i].cell, gridArray[i].value, false, false, CELL_TYPE.NORMAL);
            }

            alert("Solved grid successfully!");
        }

        function allCellsFilled (grid) {
            for (let x = 0; x < grid.length; x++) {
                if (grid[x].type == CELL_TYPE.CLUE) continue;
                if (grid[x].possible.length > 0) return false;
            }
            return true;
        }

        function solveGetAllowedValues (grid, index) {
            let cellData = grid[index];
            let allowedValues = [1,2,3,4,5,6,7,8,9];

            // Check Vertical
            for (let y = 0; y < 9; y++) {
                let checkCell = grid[y * 9 + cellData.x];
                if (checkCell.value == 0) continue;
                if (allowedValues.indexOf(Number(checkCell.value)) >= 0) {
                    allowedValues.splice(allowedValues.indexOf(Number(checkCell.value)), 1);
                }
            }

            // Check Horizontal
            for (let x = 0; x < 9; x++) {
                let checkCell = grid[cellData.y * 9 + x];
                if (checkCell.value == 0) continue;
                if (allowedValues.indexOf(Number(checkCell.value)) >= 0) {
                    allowedValues.splice(allowedValues.indexOf(Number(checkCell.value)), 1);
                }
            }

            // Check Group
            let groupX = Math.floor(cellData.x/3) * 3;
            let groupY = Math.floor(cellData.y/3) * 3;

            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    let checkCell = grid[(groupY + y) * 9 + groupX + x];
                    if (checkCell.value == 0) continue;
                    if (allowedValues.indexOf(Number(checkCell.value)) >= 0) {
                        allowedValues.splice(allowedValues.indexOf(Number(checkCell.value)), 1);
                    }
                }
            }

            return allowedValues;
        }

        function solveOnlyPossible (grid, index, value) {
            let cellData = grid[index];

            let onlyPossible = true;

            // Check rows
            for (let x = 0; x < 9; x++) {
                let checkCell = grid[cellData.y * 9 + x];
                if (checkCell.type == CELL_TYPE.CLUE || checkCell == cellData || checkCell.value != 0) continue;
                if (checkCell.possible.indexOf(value) >= 0) onlyPossible = false;
            }

            if (onlyPossible) return true;
            onlyPossible = true;

            // Check columns
            for (let y = 0; y < 9; y++) {
                let checkCell = grid[y * 9 + cellData.x];
                if (checkCell.type == CELL_TYPE.CLUE || checkCell == cellData || checkCell.value != 0) continue;
                if (checkCell.possible.indexOf(value) >= 0) onlyPossible = false;
            }

            if (onlyPossible) return true;
            onlyPossible = true;

            // Check group
            let groupX = Math.floor(cellData.x/3) * 3;
            let groupY = Math.floor(cellData.y/3) * 3;

            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    let checkCell = grid[(groupY + y) * 9 + groupX + x];
                    if (checkCell.type == CELL_TYPE.CLUE || checkCell == cellData || checkCell.value != 0) continue;
                    if (checkCell.possible.indexOf(value) >= 0) onlyPossible = false;
                }
            }

            return onlyPossible;
        }

        function solveUpdateAllowedValues (grid, index) {
            let cellData = grid[index];

            // Check Vertical
            for(let y = 0; y < 9; y++) {
                let checkCell = grid[y * 9 + cellData.x];
                if (checkCell.value != 0) continue;
                if (checkCell.possible.indexOf(cellData.value) >= 0) {
                    checkCell.possible.splice(checkCell.possible.indexOf(cellData.value), 1);
                }
            }

            // Check Horizontal
            for(let x = 0; x < 9; x++) {
                let checkCell = grid[cellData.y * 9 + x];
                if (checkCell.value != 0) continue;
                if (checkCell.possible.indexOf(cellData.value) >= 0) {
                    checkCell.possible.splice(checkCell.possible.indexOf(cellData.value), 1);
                }
            }

            // Check Group
            let groupX = Math.floor(cellData.x/3) * 3;
            let groupY = Math.floor(cellData.y/3) * 3;

            for(let x = 0; x < 3; x++) {
                for(let y = 0; y < 3; y++) {
                    let checkCell = grid[(groupY + y) * 9 + groupX + x];
                    if (checkCell.value != 0) continue;
                    if (checkCell.possible.indexOf(cellData.value) >= 0) {
                        checkCell.possible.splice(checkCell.possible.indexOf(cellData.value), 1);
                    }
                }
            }
        }

    </script>

    <script>
        initSudokuInside(document.getElementById("sudoku-root"));
    </script>
</body>
</html>
